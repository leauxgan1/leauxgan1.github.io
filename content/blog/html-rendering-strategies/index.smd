---
.title = "Implications of HTML Rendering Strategies",
.date = @date("2025-09-06T00:00:00"),
.author = "Logan Langdon",
.layout = "post.shtml",
.draft = false,
--- 

I remember first learning about web development through online resources such as W3 Schools and freecodecamp.org and understanding that there is a linear progression to advancing your expertise in web development.

First, as with any domain in computing, start with the basics; HTML, CSS and some inline scripts to get some unique behavior.

Then, once you are comfortable with those tools, move on to something more robust, like Frontend Development Libraries.

Thankfully freecodecamp does mention some more simple tools first, such as Bootstrap, SASS and JQuery which are more reasonable steps toward improved development practices.

Soon after, however, SPA frameworks are also introduced such as React and after that Redux to share state within React.

I remember that this didn't feel like that much of a difference from using JS proper, mostly because I didn't understand the implications that React imposes, namely using Client Side Rendering. 

### A beginner's perspective of the world of web development


When starting out with web fundamentals, there is usually no conception of the server.

This is done intentionally to reduce the initial load of complexity for the learner.

This is amplified by the common format of game-ifying programming lessons into bite-sized pieces that feel more satisfying to accomplish.

This culminates in the limited perspective of how an app works in its totality.

The world is:
 - My markdown which gives structure
 - My stylesheets which provide, well, style
 - My scripts which do everything else
 - (Maybe) A server which gives some info


Given this perspective, it seems like React is a great choice solely for the ability to have components which is otherwise not possible (it would seem) for the new webdev.

Instead of doing the same work over and over again, I can have a reusable section of code that I only have to define once.

And hey, that's kind of like a function! What could be more ideal for my frontend than to be a function of state.

### The true scope of the Webapp

Once more experience has been gained and projects using these technologies are experimented with, it quickly becomes evident that this perspective is quite narrow.

The main issue that presents itself is the sheer amount of fetching, either with the Fetch API or libraries like Axios, that is required to retrieve data into components.

Then again, if this fetching is minimized and more state is managed on the client, that state is often out of date as it represents the state of the server at the time of the initial fetch.

These are problems that any SPA framework would have, but React has some extra ones as well. Namely, component lifecycles and rerenders that are unintuitive for the procedural-minded developer.

Once we are given some time to zoom out, we see the true scope from the bottom-up:
 - A datastore storing persistent state our users are interested in or willingly provide to be stored
 - A cache ensuring we don't overcrowd our datastore with unnecessary reads
 - A backend which routes pipelines of data to any client asking for it
 - Middleware that validates requests and packages results 
 - Load balancers to make sure we don't overcrowd our server
 - A frontend defined with HTML, CSS and JS for interactivity which queries the server for valid state

Given this perspective, we can see that our frontend framework is actually the furthest thing from the source of truth, making it extremely inaccurate to assume as such.

### The Misapplication of 80/20

The assumption that many frontend frameworks seem to make is that a majority of the computation should be on the frontend to maximize responsiveness and the minority is sending information from the backend to the client.

This may be the case for some webapps, such as live dashboards and online games, but the ratio is flipped for the average case, even assuming you want responsiveness.

The problem with the former assumption is twofold:
 1. The dilution of state responsibility between the server and client makes app state more difficult to manage and keep up to date.
 2. The concentration of code on the frontend can reduce responsiveness when more intensive tasks could be done on a more performant backend.

Because of this, it would seem our frontends should be lightweight and simply handle easy and superficial tasks.

This is reflected by the change in direction the React ecosystem has undergone in the last decade of using Server Components in a meta-framework like Next to simplify the process.

However, the buy-in of a meta-framework like Next is quite high for what it offers and it is often completely overkill for the average webapp.

We can create smaller and simpler solutions for this purpose:

### VanillaJS & Webcomponents

In this talk at Utah JS by Maximiliano Firtman, [Vanilla JS: You Might not need that Library](https://youtu.be/V2eM0EdTfmk), the many options we have as web developers which don't involve bringing in large frontend libraries are mentioned in detail.

Firtman comes to a similar subset of the features required for the modern frontend and finds the null hypothesis for each, often using the most builtin features of the web and minimizing dependencies.

As it turns out, many of modern web-dev's needs can be served by browser APIs, such as the DOM, History, as well as the Proxy Object!

For things that truly must be encapsulated as components such that they can be repeatable and enclose their stylings, the shadow DOM is another standard that solves this seamlessly!

While some may reject these as "reinventing the wheel" there are many benefits to this approach.

Since they are smaller and simpler tools, they allow for smaller bundle sizes and more control by the developer as to how they work and interact with the rest of the frontend.

This approach allows you to compose your reactivity model with your components rather than coupling them out of the box. 

I can choose to use vanilla web components with alpine's reactivity through inline attributes.

I could choose to use Lit-html's components with full rerenders or their experiemental preact signals package.

I can opt for a bare-bones approach, defining a render component which I called whenever I change state internally.

I could ditch reactivity altogether and just allow the server to rerender pages or fragments if the cost of doing so is minimal.

Speaking of which:

### Simulating the SPA with an MPA: HATEOAS 

An approach becoming more popular nowadays with smaller apps is to use a hypermedia-centric library such as HTMX to drive the state of an application.

This approach fully rejects the idea that decoupling your data from your UI is a good idea, because often times its not actually necessary.

Hypermedia as the engine of applicaction state or HATEOAS instead focuses on cohesion between your state and your UI, turning your UI into an actual function of your server state.

Oftentimes as developers we try to not close off windows of opportunity and possible extension, and this is evident with the JSON based server.

"What if I need to support mobile? Or use this as a generic API?"

What this generic-first approach means in practice is that your server and each of your clients have to reify their perfectly generic state into a proper view, going through the steps of:

Server:
1. Serialize DB state to JSON
2. Send JSON data

Client: 
1. Receive json data
2. Deserialize data
3. Render data into an HTML template

With any hypermedia approach, this is simplified to
Server:
1. Serialize DB state to HTML
2. Send HTML to client

Client:
1. Receive HTML data
2. Place HTML on page

Rather than two transformations of the data, the data only underwent one. Success!

#### Diversity in Hypermedia

With HTMX being the biggest name in the HATEOAS space at the moment, most of the assumptions about HATEOAS and its capabilities are based on HTMX's capabilities.

This is far from accurate, as HATEOAS just limits you to using, well, Hypermedia.

But there are many more considerations such as what kind of Hypermedia to use, how to specify partial rerenders, and what additional features to use to enhance the experience for users.

#### Datastar

By far my favorite approach to HATEOAS is not a hypermedia library, but a hypermedia framework!

Datastar takes from HTMX's methodology and improves upon key aspects where it is sorely lacking, such as realtime updates and small client side updates and state.

Most of all, Datastar focuses on empowering the server to have as much control as possible over the frontend state, such as using the common id of a fragment and an element on the page to choose what to update.

Datastar also solves the need for a client-side state library by providing a signal implementation out of the box that is also accessible to the server to update the frontend!

All of these improvements make Datastar the choice for me to simplify web development.

### Conclusion

With hindsight, we can look back at the recent history of modern web development and learn from our mistakes.

The greatest mistake we have made is in choosing client-side rendering as the only way to have responsive pages.

Furthermore, we have valued responsiveness over many other goals to strive for:
 - Reliability
 - Simplicity
 - Accessibility

With awareness of these pitfalls, we can choose to use different tools to make our lives easier

- Logan
